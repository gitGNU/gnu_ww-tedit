/*
  fpconf.h:
    Configuration for handling floating point and integer exceptions and
    errors.

  Unfortunately there is no common way to trap *all* errors. All means:
    1. Errors generated by MATH.H functions like sqrt(-1.0)
    2. Integer division by zero
    3. Floating point errors like underflow, loss of precision, etc.

  This file provides definitions which attempt to handle these errors
  for different compilers and platforms. The approcach we take is to try
  to *ignore* most errors hoping that the result will still make sense.
  For example floating point divisions by zero would produce infinity.

  It can be argued whether the opposite approach (catching all errors and
  aborting the computation) is better. For one it is much more difficult
  to implement in different environments. Also in many cases it is still
  better to obtain *any* even aproximate result than just "Floating Point
  Error".
*/

/*************************************************************************
  Define a way to disable the floating point exceptions.

  DISABLE_FP_EXCEPTIONS
    Save the current state of FP exceptions and disable them.

  RESTORE_FP_EXCEPTIONS
    Restore the state of the FP exceptions saved by DISABLE_FP_EXCEPTIONS

  Note: DISABLE_FP_EXCEPTIONS and RESTORE_FP_EXCEPTIONS will always be used
  in a common local block, so DISABLE_FP_EXCEPTIONS can use a local variable
  to store the exception state.

  CLEAR_FP_STATE()
    Reset the FP state after an exception has occured. Obviously this
    macro won't neet to actually be called if the exceptions have been
    sucessfully isabled.
*/

#if defined(_MSC_VER) || defined(__TURBOC__) || defined(__DJGPP__)
  // Visual C
  // Turbo C, Borland C, CBuilder
  // DJGPP
  //
  #define DISABLE_FP_EXCEPTIONS                  \
    {                                            \
      volatile unsigned saveExcMask = _control87( 0, 0 ); \
      _control87( ~0u, MCW_EM );

  #define RESTORE_FP_EXCEPTIONS                  \
      _clear87();                                \
      _control87( saveExcMask, MCW_EM );         \
    }

  #define CLEAR_FP_STATE()  _clear87()

#endif


/***************************************************************************
  Specify whether SIG_FPE is raised on integer division by zero.

  DIV0_SIGNAL = 1 : SIG_FPE is raised on integer division by zero
              = 0 : no signal is raised on integer division by zero
*/

#if defined(__TURBOC__)
  #define DIV0_SIGNAL  1
#endif

/***************************************************************************
  Define the signature of the matherr function (if there is any at all).

  MATHERR_SIG
    the signature of the matherr function. For some compilers it is called
    "_matherr", for others plain "matherr", some have no arguments, others
    have an argument of type "_exception" or "exception" ...
*/

#if defined(_MSC_VER)
  // Visual C
  //
  #define MATHERR_SIG   int _matherr ( struct _exception * e )

#elif defined(__TURBOC__) && defined(_WIN32)
  // CBuilder
  //
  #define MATHERR_SIG   int _matherr ( struct exception * e )

#elif defined(__TURBOC__) || defined(__DJGPP__)
  // TurboC - DOS, DJGPP - DOS
  //
  #define MATHERR_SIG   int matherr ( struct exception * e )

#elif defined(__unix__)
  // Tested on Linux only, supposed to work on all GLIBC on various UNIX versions
  //
  // petar: this failed on cygwin?!
  // #define MATHERR_SIG   int matherr __P ((struct exception *__exc))
  #define MATHERR_SIG   int matherr (struct exception *__exc)

#endif


// Define the defaults of the macroses
//
#ifndef DISABLE_FP_EXCEPTIONS
  #define DISABLE_FP_EXCEPTIONS
#endif
#ifndef RESTORE_FP_EXCEPTIONS
  #define RESTORE_FP_EXCEPTIONS
#endif
#ifndef CLEAR_FP_STATE
  #define CLEAR_FP_STATE()
#endif
#ifndef DIV0_SIGNAL
  #define DIV0_SIGNAL  0
#endif
#ifndef MATHERR_SIG
  #define MATHERR_SIG  int matherr ( void )
#endif

